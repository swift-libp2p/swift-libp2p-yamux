//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-libp2p open source project
//
// Copyright (c) 2022-2025 swift-libp2p project authors
// Licensed under MIT
//
// See LICENSE for license information
// See CONTRIBUTORS for the list of swift-libp2p project authors
//
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
//
// This source file is part of the SwiftNIO open source project
//
// Copyright (c) 2020 Apple Inc. and the SwiftNIO project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of SwiftNIO project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import Atomics
import LibP2P
import NIOConcurrencyHelpers
import NIOCore

/// A NIO `Channel` that encapsulates a single YAMUX `Channel`.
final class ChildChannel {

    private var _pipeline: ChannelPipeline!

    private let closePromise: EventLoopPromise<Void>

    private let multiplexer: ChannelMultiplexer

    private var state: ChildChannelStateMachine

    private var windowManager: ChildChannelWindowManager

    /// If close0 was called but the channel could not synchronously close (because it's currently
    /// active), the promise is stored here until it can be fulfilled.
    private var pendingClosePromise: EventLoopPromise<Void>?

    /// A buffer of pending inbound reads delivered from the parent channel.
    private var pendingReads: CircularBuffer<PendingContent> = CircularBuffer(initialCapacity: 8)

    /// Whether `autoRead` is enabled. By default, all `ChildChannel` objects inherit their `autoRead`
    /// state from their parent.
    private var autoRead: Bool

    /// Whether this channel supports remote half-closure. By default this is set to false.
    private var allowRemoteHalfClosure: Bool

    /// Whether a call to `read` has happened without any messages available to read (that is, whether newly
    /// received messages should be immediately delivered to the pipeline).
    private var unsatisfiedRead: Bool = false

    /// Whether we had written an automatic (i.e. generated by this channel) message.
    private var didWriteAutomaticMessage: Bool

    /// A buffer of pending outbound writes from the user.
    ///
    /// To correctly respect flushes, we deliberately withold data from the parent channel until this
    /// stream is flushed, at which time we deliver them all. This buffer holds the pending ones.
    private var pendingWritesFromChannel: MarkedCircularBuffer<(PendingContent, EventLoopPromise<Void>?)> =
        MarkedCircularBuffer(initialCapacity: 8)

    /// A buffer of pending outbound messages for the parent channel.
    ///
    /// This buffer exists to avoid message re-ordering issues when we make outcalls. Some messages
    /// trigger multiple outcalls, any of which could interrupt message delivery or event ordering.
    /// To avoid difficulty here, we make sure we enqueue the writes for the multiplexer here.
    private var pendingWritesForMultiplexer: CircularBuffer<(Message, EventLoopPromise<Void>?)> = CircularBuffer(
        initialCapacity: 8
    )

    /// An object that controls whether this channel should be writable.
    private var writabilityManager: ChildChannelWritabilityManager

    /// The max message size set by the peer. We initialize it to zero to begin with.
    private var peerMaxMessageSize: UInt32

    private var activationState: ActivationState

    // MARK: Stored properties for channel/channelcore conformance.

    public let allocator: ByteBufferAllocator

    public let parent: Channel?

    public let eventLoop: EventLoop

    private let _isWritable: ManagedAtomic<Bool>

    private let _isActive: ManagedAtomic<Bool>

    typealias Initializer = (Channel) -> EventLoopFuture<Void>

    private var initializer: Initializer?

    private var didClose = false

    /// A promise from the user that will be fired when the channel goes active.
    private var userActivatePromise: EventLoopPromise<Channel>?

    private var channelID: UInt32

    private var logger: Logger

    private var shouldCloseOnceFlushed: EventLoopPromise<Void>? = nil

    internal convenience init(
        allocator: ByteBufferAllocator,
        parent: Channel,
        multiplexer: ChannelMultiplexer,
        initializer: Initializer?,
        localChannelID: UInt32,
        targetWindowSize: Int32,
        initialOutboundWindowSize: UInt32,
        direction: LibP2P.Mode,
        logger: Logger
    ) {
        self.init(
            allocator: allocator,
            parent: parent,
            multiplexer: multiplexer,
            initializer: initializer,
            initialState: .init(localChannelID: localChannelID),
            targetWindowSize: targetWindowSize,
            initialOutboundWindowSize: initialOutboundWindowSize,
            channelID: localChannelID,
            direction: direction,
            logger: logger
        )
    }

    private init(
        allocator: ByteBufferAllocator,
        parent: Channel,
        multiplexer: ChannelMultiplexer,
        initializer: Initializer?,
        initialState: ChildChannelStateMachine,
        targetWindowSize: Int32,
        initialOutboundWindowSize: UInt32,
        channelID: UInt32,
        direction: LibP2P.Mode,
        logger: Logger
    ) {
        self.allocator = allocator
        self.closePromise = parent.eventLoop.makePromise()
        self.parent = parent
        self.eventLoop = parent.eventLoop
        self.multiplexer = multiplexer
        self.initializer = initializer
        self.windowManager = ChildChannelWindowManager(targetWindowSize: UInt32(targetWindowSize))
        self._isWritable = .init(true)
        self._isActive = .init(false)
        self.state = initialState
        self.writabilityManager = ChildChannelWritabilityManager(
            initialWindowSize: initialOutboundWindowSize,
            parentIsWritable: parent.isWritable
        )
        self.peerMaxMessageSize = 0
        self.channelID = channelID
        self.logger = logger
        self.logger[metadataKey: "YAMUX"] = .string("Child[\(channelID)][\(direction == .listener ? "IN" : "OUT")]")

        // To begin with we initialize autoRead and halfClosure to false, but we are going to fetch it from our parent before we
        // go much further.
        self.autoRead = false
        self.allowRemoteHalfClosure = false
        self.didWriteAutomaticMessage = false
        self.activationState = .neverActivated
        self._pipeline = ChannelPipeline(channel: self)
    }
}

// `ChildChannel` protects its shared state by dispatching to its associated `eventLoop`
extension ChildChannel: @unchecked Sendable {}

extension ChildChannel: Channel, ChannelCore {
    public var closeFuture: EventLoopFuture<Void> {
        self.closePromise.futureResult
    }

    public var pipeline: ChannelPipeline {
        self._pipeline
    }

    public var localAddress: SocketAddress? {
        self.parent.flatMap { $0.localAddress }
    }

    public var remoteAddress: SocketAddress? {
        self.parent.flatMap { $0.remoteAddress }
    }

    func localAddress0() throws -> SocketAddress {
        try self.parent!._channelCore.localAddress0()
    }

    func remoteAddress0() throws -> SocketAddress {
        try self.parent!._channelCore.localAddress0()
    }

    func setOption<Option: ChannelOption>(_ option: Option, value: Option.Value) -> EventLoopFuture<Void> {
        if self.eventLoop.inEventLoop {
            do {
                return self.eventLoop.makeSucceededFuture(try self.setOption0(option, value: value))
            } catch {
                return self.eventLoop.makeFailedFuture(error)
            }
        } else {
            return self.eventLoop.submit { try self.setOption0(option, value: value) }
        }
    }

    public func getOption<Option: ChannelOption>(_ option: Option) -> EventLoopFuture<Option.Value> {
        if self.eventLoop.inEventLoop {
            do {
                return self.eventLoop.makeSucceededFuture(try self.getOption0(option))
            } catch {
                return self.eventLoop.makeFailedFuture(error)
            }
        } else {
            return self.eventLoop.submit { try self.getOption0(option) }
        }
    }

    private func setOption0<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
        self.eventLoop.preconditionInEventLoop()

        switch option {
        case _ as ChannelOptions.Types.AutoReadOption:
            self.autoRead = value as! Bool
        case _ as ChannelOptions.Types.AllowRemoteHalfClosureOption:
            self.allowRemoteHalfClosure = value as! Bool
        default:
            fatalError("setting option \(option) on ChildChannel not supported")
        }
    }

    private func getOption0<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
        self.eventLoop.preconditionInEventLoop()

        switch option {
        case _ as ChildChannelOptions.Types.LocalChannelIdentifierOption:
            return self.state.localChannelIdentifier as! Option.Value
        case _ as ChildChannelOptions.Types.RemoteChannelIdentifierOption:
            return self.state.remoteChannelIdentifier as! Option.Value
        case _ as ChildChannelOptions.Types.PeerMaximumMessageLengthOption:
            return self.peerMaxMessageSize as! Option.Value
        case _ as ChannelOptions.Types.AutoReadOption:
            return self.autoRead as! Option.Value
        case _ as ChannelOptions.Types.AllowRemoteHalfClosureOption:
            return self.allowRemoteHalfClosure as! Option.Value
        default:
            fatalError("option \(option) not supported on ChildChannel")
        }
    }

    public var isWritable: Bool {
        self._isWritable.load(ordering: .relaxed)
    }

    public var isActive: Bool {
        self._isActive.load(ordering: .relaxed)
    }

    public var _channelCore: ChannelCore {
        self
    }

    public func register0(promise: EventLoopPromise<Void>?) {
        fatalError("not implemented \(#function)")
    }

    public func bind0(to: SocketAddress, promise: EventLoopPromise<Void>?) {
        fatalError("not implemented \(#function)")
    }

    public func connect0(to: SocketAddress, promise: EventLoopPromise<Void>?) {
        fatalError("not implemented \(#function)")
    }

    public func write0(_ data: NIOAny, promise: EventLoopPromise<Void>?) {
        self.logger.trace("write0 called")
        guard !self.state.isClosed else {
            promise?.fail(ChannelError.ioOnClosedChannel)
            return
        }

        let bodyData = self.unwrapData(data, as: ByteBuffer.self)
        let writeSize = bodyData.readableBytes

        if bodyData.readableBytes > 256 {
            self.logger.trace("write0 -> \(bodyData.readableBytes) bytes")
        } else {
            self.logger.trace("write0 -> \(String(data: Data(bodyData.readableBytesView), encoding: .utf8) ?? "NIL")")
        }

        self.pendingWritesFromChannel.append((.data(bodyData), promise))

        // Ok, we can make an outcall now, which means we can safely deal with the flow control.
        if case .changed(newValue: let value) = self.writabilityManager.bufferedBytes(writeSize) {
            self.changeWritability(to: value)
        }
    }

    public func flush0() {
        self.pendingWritesFromChannel.mark()

        if self.isActive {
            self.deliverPendingWrites()
        }

        self.writePendingToMultiplexer()
    }

    public func read0() {
        if self.unsatisfiedRead {
            // We already have an unsatisfied read, let's do nothing.
            return
        }

        // At this stage, we have an unsatisfied read. If there is no pending data to read,
        // we're going to call read() on the parent channel. Otherwise, we're going to
        // succeed the read out of our pending data.
        self.unsatisfiedRead = true
        if self.pendingReads.count > 0 {
            self.tryToRead()
        } else {
            self.parent?.read()
        }

        // We may have generated automatic messages here.
        self.writePendingToMultiplexer()
    }

    public func close0(error: Error, mode: CloseMode, promise: EventLoopPromise<Void>?) {
        // Can't process this right now.

        self._actuallyClose0(error: error, mode: mode, promise: promise)
    }

    private func _actuallyClose0(error: Error, mode: CloseMode, promise: EventLoopPromise<Void>?) {
        // If the stream is already closed, we can fail this early and abort processing.
        guard !self.state.isClosed else {
            promise?.fail(ChannelError.alreadyClosed)
            return
        }

        switch mode {
        case .input:
            // We can't close the input in SSH.
            promise?.fail(ChannelError.operationUnsupported)
            return

        case .output:
            // Closing output turns into sending a frame.
            // This message needs to be buffered with the outbound I/O. It also counts as a flush (because
            // closing is normally not something that can be flushed).
            promise?.fail(ChannelError.operationUnsupported)
            //self.pendingWritesFromChannel.append((.eof, promise))
            //self.flush0()
            return

        case .all:
            // Store the pending close promise: it'll be succeeded later.
            if let promise = promise {
                if let pendingPromise = self.pendingClosePromise {
                    pendingPromise.futureResult.cascade(to: promise)
                } else {
                    self.pendingClosePromise = promise
                }
            }

            if self.state.isActiveOnNetwork {
                // Gotta do some I/O.
                self.closedWhileOpen()
            } else {
                // The channel isn't active on the network, just go straight to closedCleanly.
                self.closedCleanly()
            }
        }
    }

    public func triggerUserOutboundEvent0(_ event: Any, promise: EventLoopPromise<Void>?) {
        promise?.fail(YAMUX.Error.unsupportedChannelEvent(event: "\(event)"))
        return
    }

    public func channelRead0(_: NIOAny) {
        // do nothing
    }

    public func errorCaught0(error: Error) {
        // do nothing
    }

    internal func configure(userPromise: EventLoopPromise<Channel>?) {
        // We need to configure this channel. This involves doing four things:
        // 1. Setting our autoRead state from the parent
        // 2. Calling the initializer, if provided.
        // 3. Activating when complete.
        // 4. Catching errors if they occur.
        let f = self.parent!.getOption(ChannelOptions.autoRead).flatMap { autoRead -> EventLoopFuture<Void> in
            self.logger.trace("Setting AutoRead to \(autoRead)")
            self.autoRead = autoRead
            let initializer = self.initializer
            self.initializer = nil
            return initializer?(self) ?? self.eventLoop.makeSucceededFuture(())
        }.map {
            self.initializerComplete(userPromise: userPromise)
        }

        f.whenFailure { (error: Error) in
            self.initializerFailed(error: error)
            userPromise?.fail(error)
        }
    }

    /// Activates this channel.
    fileprivate func performActivation() {
        // We validate that the parent is active, and that we're active on the network, and that we haven't
        // activated already before we proceed. This makes this method idempotent.
        guard let parent = self.parent, parent.isActive, self.state.isActiveOnNetwork,
            case .neverActivated = self.activationState
        else {
            return
        }

        self.notifyChannelActive()
        if !self.writabilityManager.isWritable {
            self.changeWritability(to: false)
        }
        self.tryToAutoRead()
        self.deliverPendingWrites()
        self.writePendingToMultiplexer()
        if let promise = self.userActivatePromise {
            self.userActivatePromise = nil
            promise.succeed(self)
        }
        self.logger.trace("Performed Activation")
    }

    private func initializerComplete(userPromise: EventLoopPromise<Channel>?) {
        // We need to work out what we need to do once the initializer completes.
        self.userActivatePromise = userPromise

        if self.state.isActiveOnNetwork {
            self.logger.trace("Initializer Complete - Active on Network")
            // We need to send a channelOpenSuccess.
            let message = Message.ChannelOpenConfirmationMessage(
                recipientChannel: self.state.remoteChannelIdentifier!,
                senderChannel: self.state.localChannelIdentifier,
                initialWindowSize: self.windowManager.targetWindowSize,
                maximumPacketSize: self.windowManager.targetWindowSize  // 1 << 24
            )  // This is a weirdly hard-coded choice.
            self.processOutboundMessage(.channelOpenConfirmation(message), promise: nil)
            self.writePendingToMultiplexer()
        } else if !self.state.isClosed {
            self.logger.trace("Initializer Complete - Not Closed")
            // We need to request the channel. We must have the channel by now.
            let message = Message.ChannelOpenMessage(
                senderChannel: self.state.localChannelIdentifier,
                initialWindowSize: self.windowManager.targetWindowSize,
                maximumPacketSize: self.windowManager.targetWindowSize  // 1 << 24
            )
            self.processOutboundMessage(.channelOpen(message), promise: nil)
            self.writePendingToMultiplexer()
        } else {
            // Already closed, just fail this promise.
            self.logger.trace("Initializer Complete - Already Closed")
            self.closeFuture.cascadeFailure(to: userPromise)
        }
        self.logger.trace("Initializer Complete")
    }

    private func initializerFailed(error: Error) {
        // Tell the remote peer to go away.
        if self.state.isActiveOnNetwork {
            let message = Message.ChannelOpenFailureMessage(
                recipientChannel: self.state.remoteChannelIdentifier!,
                reasonCode: YAMUX.NetworkError.internalError.code,
                description: "",
                language: "en-US"
            )
            self.processOutboundMessage(.channelOpenFailure(message), promise: nil)
            self.writePendingToMultiplexer()
        } else {
            self.errorEncountered(error: error)
        }
        self.logger.warning("Initializer Failed")
    }

    /// Called when the channel was closed from the pipeline while the stream is still open.
    ///
    /// Will emit a `MSG_CHANNEL_CLOSE` to close the channel.
    private func closedWhileOpen() {
        precondition(!self.state.isClosed)

        if self.state.sentClose {
            // Already sent a close, do nothing else.
            return
        }

        let message = Message.ChannelCloseMessage(recipientChannel: self.state.remoteChannelIdentifier!)
        self.processOutboundMessage(.channelClose(message), promise: nil)
        self.writePendingToMultiplexer()
    }

    private func closedCleanly() {
        precondition(!self.state.isActiveOnNetwork)

        self.logger.trace("ClosedCleanly Called")
        // We use didClose as a gating mechanism: only one of closedCleanly
        // or errorEncountered ever gets to run. This is important, as errorEncountered
        // can actually trigger closedCleanly.
        if self.didClose {
            // We've already closed
            return
        }
        self.didClose = true

        self.deliverPendingReads()
        self.failPendingWrites(error: ChannelError.eof)
        if let promise = self.pendingClosePromise {
            self.pendingClosePromise = nil
            promise.succeed(())
        }
        if let promise = self.userActivatePromise {
            // NOTE(cory): I don't think we can actually hit this? It's a useful fallback though: we have it in
            // case a programming error occurs, because it's semantically right and avoids a crash.
            self.userActivatePromise = nil
            promise.fail(ChannelError.eof)
        }

        self.notifyChannelInactive()

        self.logger.trace("Tearing Down ChildChannel")
        self.eventLoop.execute {
            self.removeHandlers(pipeline: self.pipeline)
            self.closePromise.succeed(())
            self.multiplexer.childChannelClosed(channelID: self.state.localChannelIdentifier)
        }
    }

    fileprivate func errorEncountered(error: Error) {
        self.logger.error("\(error)")
        // We use didClose as a gating mechanism: only one of closedCleanly
        // or errorEncountered ever gets to run. This is important, as errorEncountered
        // can actually trigger closedCleanly.
        if self.didClose {
            return
        }
        self.didClose = true

        self.deliverPendingReads()
        self.failPendingWrites(error: error)
        if let promise = self.pendingClosePromise {
            self.pendingClosePromise = nil
            promise.fail(error)
        }
        if let promise = self.userActivatePromise {
            self.userActivatePromise = nil
            promise.fail(error)
        }
        self.pipeline.fireErrorCaught(error)
        self.notifyChannelInactive()

        // Ok, we need to notify the network that we're done.
        if self.state.isActiveOnNetwork, !self.state.sentClose {
            let message = Message.ChannelCloseMessage(recipientChannel: self.state.localChannelIdentifier)
            self.processOutboundMessage(.channelClose(message), promise: nil)
            self.writePendingToMultiplexer()
        }

        self.eventLoop.execute {
            self.removeHandlers(pipeline: self.pipeline)
            self.closePromise.fail(error)
            self.multiplexer.childChannelErrored(
                channelID: self.state.localChannelIdentifier,
                expectClose: !self.state.isClosed
            )
        }
    }

    private func tryToRead() {
        // If there's no read to satisfy, no worries about it.
        guard self.unsatisfiedRead else {
            self.logger.trace("TryToRead -> No unsatisfied read")
            return
        }

        // If we're not active, we will hold on to these reads.
        guard self.state.isActiveOnChannel else {
            self.logger.trace("TryToRead -> Not active on channel, holding onto \(self.pendingReads.count) messages")
            return
        }

        // If there are no pending reads, do nothing.
        guard self.pendingReads.count > 0 else {
            self.logger.trace("TryToRead -> No pending reads")
            return
        }

        // Ok, we're satisfying a read here.
        self.unsatisfiedRead = false
        self.deliverPendingReads()
        self.tryToAutoRead()
    }

    private func changeWritability(to newWritability: Bool) {
        self.logger.trace("Writability Changed -> \(newWritability)")
        self._isWritable.store(newWritability, ordering: .relaxed)
        self.pipeline.fireChannelWritabilityChanged()
    }

    private func tryToAutoRead() {
        if self.autoRead {
            // If auto-read is turned on, recurse into channelPipeline.read().
            // This cannot recurse indefinitely unless frames are being delivered
            // by the read stacks, which is generally fairly unlikely to continue unbounded.
            self.pipeline.read()
        }
    }
}

// MARK: - Functions used to manage pending reads and writes.

extension ChildChannel {
    /// Deliver reads to the channel.
    ///
    /// This is sometimes done when the channel itself is closed, because data loss in these circumstances is unacceptable.
    private func deliverPendingReads() {
        while self.pendingReads.count > 0 {
            self.deliverSingleRead(self.pendingReads.removeFirst())
        }
        self.pipeline.fireChannelReadComplete()
    }

    private func deliverSingleRead(_ data: PendingContent) {
        self.logger.trace("DeliverSingleRead")
        switch data {
        case .data(let data):
            // We only futz with the window manager if the channel is not already closed.
            if !self.didClose, !self.state.sentClose,
                let increment = self.windowManager.unbufferBytes(data.readableBytes)
            {
                self.logger.trace("Emitting Window Adjustment -> \(increment)")
                let update = Message.ChannelWindowAdjustMessage(
                    recipientChannel: self.state.remoteChannelIdentifier!,
                    bytesToAdd: UInt32(increment)
                )
                self.processOutboundMessage(.channelWindowAdjust(update), promise: nil)
            }

            self.pipeline.fireChannelRead(data)
        }
    }

    /// Delivers all pending flushed writes to the parent channel.
    private func deliverPendingWrites() {
        while self.pendingWritesFromChannel.hasMark, self.writabilityManager.windowSpaceOnNetwork > 0,
            var write = self.pendingWritesFromChannel.first
        {
            let maxWriteLength = min(self.writabilityManager.windowSpaceOnNetwork, Int(self.peerMaxMessageSize))
            self.logger.trace("WriteManager::\(self.writabilityManager)")
            self.logger.trace(
                "MaxWriteLength::min(\(self.writabilityManager.windowSpaceOnNetwork), \(self.peerMaxMessageSize))"
            )
            let (actualWrite, excess) = write.0.trim(maxLength: maxWriteLength)
            if let excess {
                self.logger.trace(
                    "Splitting Write:: Total: \(write.0.readableBytes) First: \(actualWrite.readableBytes) Excess: \(excess.readableBytes)"
                )
            }
            write.0 = actualWrite

            if let excess = excess {
                // We need to push the excess back on to the queue.
                self.pendingWritesFromChannel[self.pendingWritesFromChannel.startIndex] = (excess, write.1)
                write.1 = nil
            } else {
                // Drop the first write.
                _ = self.pendingWritesFromChannel.popFirst()
            }

            let writeSize = write.0.readableBytes

            if case .changed(newValue: let value) = self.writabilityManager.wroteBytes(writeSize) {
                self.changeWritability(to: value)
            }

            self.processOutboundMessage(write.0, promise: write.1)
        }

        if pendingWritesFromChannel.isEmpty, let shouldClosePromise = shouldCloseOnceFlushed {
            self.logger.trace("Closing now that all pending writes have been flushed.")
            self.shouldCloseOnceFlushed = nil
            self.processOutboundMessage(.channelClose(.init(recipientChannel: channelID)), promise: shouldClosePromise)
        }
    }

    /// Fails all pending writes with the given error.
    private func failPendingWrites(error: Error) {
        while self.pendingWritesFromChannel.count > 0 {
            self.pendingWritesFromChannel.removeFirst().1?.fail(error)
        }
    }
}

// MARK: - Inbound message handling.

extension ChildChannel {
    /// Called when a frame is received from the network.
    ///
    /// - parameters:
    ///     - frame: The `Message` received from the network.
    func receiveInboundMessage(_ message: Message) {
        self.logger.trace("Recv -> \(message)")
        do {
            switch message {
            case .channelOpen(let message):
                try self.handleInboundChannelOpen(message)
            case .channelOpenConfirmation(let message):
                try self.handleInboundChannelOpenConfirmation(message)
            case .channelOpenFailure(let message):
                try self.handleInboundChannelOpenFailure(message)
            case .channelClose(let message):
                try self.handleInboundChannelClose(message)
            case .channelReset(let message):
                try self.handleInboundChannelReset(message)
            case .channelWindowAdjust(let message):
                try self.handleInboundChannelWindowAdjust(message)
            case .channelData(let message):
                guard message.data.readableBytes > 0 else {
                    self.logger.trace("Skipping empty data frame!")
                    return
                }
                try self.handleInboundChannelData(message)
            default:
                preconditionFailure("Channels only handle channel messages")
            }
        } catch {
            self.errorEncountered(error: error)
        }
    }

    private func handleInboundChannelOpen(_ message: Message.ChannelOpenMessage) throws {
        self.state.receiveChannelOpen(message)

        // Window size starts at zero, so we treat this as an increment. However, we disregard whether this changed
        // the writability value, as we lie about writability until we're active anyway.
        _ = try self.writabilityManager.outboundWindowIncremented(message.initialWindowSize)
        self.peerMaxMessageSize = message.maximumPacketSize

        // If we got through the state machine, this is a channel opening maneuver. We can
        // now kick off the initializer. Inbound channels never have user promises.
        self.configure(userPromise: nil)
    }

    private func handleInboundChannelOpenConfirmation(_ message: Message.ChannelOpenConfirmationMessage) throws {
        try self.state.receiveChannelOpenConfirmation(message)

        // Window size starts at zero, so we treat this as an increment. However, we disregard whether this changed
        // the writability value, as we lie about writability until we're active anyway.
        _ = try self.writabilityManager.outboundWindowIncremented(message.initialWindowSize)
        self.peerMaxMessageSize = message.maximumPacketSize

        self.performActivation()
    }

    private func handleInboundChannelOpenFailure(_ message: Message.ChannelOpenFailureMessage) throws {
        try self.state.receiveChannelOpenFailure(message)
        self.errorEncountered(
            error: YAMUX.Error.channelSetupRejected(reasonCode: message.reasonCode, reason: message.description)
        )
    }

    private func handleInboundChannelReset(_ message: Message.ChannelResetMessage) throws {
        try self.state.receiveChannelReset(message)

        // Resets don't support half-closures. That puts us in a bit of a bind. We have to promote this up to full-closure.
        // We need to send a channel close, so let's just do that: the outbound state machine will make this a full-closure.
        //let closeMessage = Message.channelClose(.init(recipientChannel: self.state.remoteChannelIdentifier!))
        //self.processOutboundMessage(closeMessage, promise: nil)

        self.closedCleanly()
    }

    private func handleInboundChannelClose(_ message: Message.ChannelCloseMessage) throws {
        try self.state.receiveChannelClose(message)

        // If we didn't throw, this must be acceptable to process.
        if self.state.isClosed {
            self.closedCleanly()
        } else {
            // We need to issue a close immediately.
            let closeMessage = Message.channelClose(.init(recipientChannel: self.state.remoteChannelIdentifier!))
            self.processOutboundMessage(closeMessage, promise: nil)
        }
    }

    private func handleInboundChannelWindowAdjust(_ message: Message.ChannelWindowAdjustMessage) throws {
        self.logger.trace("Received Inbound ChannelWindowAdjust message")
        try self.state.receiveChannelWindowAdjust(message)

        if case .changed(let newValue) = try self.writabilityManager.outboundWindowIncremented(message.bytesToAdd) {
            self.changeWritability(to: newValue)
        }
        self.logger.trace("\(self.writabilityManager)")

        // There may be writes to deliver, deliver them.
        self.deliverPendingWrites()
    }

    private func handleInboundChannelData(_ message: Message.ChannelDataMessage) throws {
        // Validate this data in the state machine.
        try self.state.receiveChannelData(message)

        // State machine is happy. Handle the flow control.
        try self.windowManager.bufferFlowControlledBytes(message.data.readableBytes)
        self.pendingReads.append(.data(message.data))
    }
}

// MARK: Outbound message handling.

extension ChildChannel {
    /// Called to send a message to the network.
    ///
    /// For flow controlled messages, this may only be invoked once flow control has been
    /// satisfied.
    ///
    /// - parameters:
    ///     - frame: The `Message` to send to the network.
    ///     - promise: The promise associated with the message write, if any.
    internal func processOutboundMessage(_ message: Message, promise: EventLoopPromise<Void>?) {
        self.logger.trace("Sending -> \(message)")
        do {
            switch message {
            case .channelOpen(let message):
                try self.handleOutboundChannelOpen(message, promise)
            case .channelOpenConfirmation(let message):
                try self.handleOutboundChannelOpenConfirmation(message, promise)
            case .channelOpenFailure(let message):
                try self.handleOutboundChannelOpenFailure(message, promise)
            case .channelClose(let message):
                if pendingWritesFromChannel.isEmpty {
                    try self.handleOutboundChannelClose(message, promise)
                } else {
                    self.shouldCloseOnceFlushed = promise
                }
            case .channelWindowAdjust(let message):
                try self.handleOutboundChannelWindowAdjust(message, promise)
            case .channelData(let message):
                try self.handleOutboundChannelData(message, promise)
            default:
                preconditionFailure("Channels only handle channel messages")
            }
        } catch {
            // Oof, state machine didn't like this much.
            promise?.fail(error)
            self.errorEncountered(error: error)
            return
        }
    }

    /// A helper function for transforming `SSHChannelData` into `Message`s before processing.
    private func processOutboundMessage(_ content: PendingContent, promise: EventLoopPromise<Void>?) {
        let recipientChannel = self.state.remoteChannelIdentifier!

        switch content {
        case .data(let buffer):
            let message = Message.channelData(
                Message.ChannelDataMessage(recipientChannel: recipientChannel, data: buffer)
            )
            self.processOutboundMessage(message, promise: promise)
        }
    }

    private func handleOutboundChannelOpen(
        _ message: Message.ChannelOpenMessage,
        _ promise: EventLoopPromise<Void>?
    ) throws {
        self.state.sendChannelOpen(message)
        self.pendingWritesForMultiplexer.append((.channelOpen(message), promise))
    }

    private func handleOutboundChannelOpenConfirmation(
        _ message: Message.ChannelOpenConfirmationMessage,
        _ promise: EventLoopPromise<Void>?
    ) throws {
        self.state.sendChannelOpenConfirmation(message)
        self.pendingWritesForMultiplexer.append((.channelOpenConfirmation(message), promise))
        self.performActivation()
    }

    private func handleOutboundChannelOpenFailure(
        _ message: Message.ChannelOpenFailureMessage,
        _ promise: EventLoopPromise<Void>?
    ) throws {
        self.state.sendChannelOpenFailure(message)
        self.pendingWritesForMultiplexer.append((.channelOpenFailure(message), promise))
        self.errorEncountered(
            error: YAMUX.Error.channelSetupRejected(reasonCode: message.reasonCode, reason: message.description)
        )
    }

    private func handleOutboundChannelClose(
        _ message: Message.ChannelCloseMessage,
        _ promise: EventLoopPromise<Void>?
    ) throws {
        try self.state.sendChannelClose(message)

        // All other channels send regular fin flags
        self.pendingWritesForMultiplexer.append((.channelClose(message), promise))

        // If we didn't throw, this must be acceptable to process.
        if self.state.isClosed {
            self.closedCleanly()
        }
    }

    private func handleOutboundChannelWindowAdjust(
        _ message: Message.ChannelWindowAdjustMessage,
        _ promise: EventLoopPromise<Void>?
    ) throws {
        try self.state.sendChannelWindowAdjust(message)
        self.pendingWritesForMultiplexer.append((.channelWindowAdjust(message), promise))
    }

    private func handleOutboundChannelData(
        _ message: Message.ChannelDataMessage,
        _ promise: EventLoopPromise<Void>?
    ) throws {
        // Validate this data in the state machine.
        try self.state.sendChannelData(message)
        self.pendingWritesForMultiplexer.append((.channelData(message), promise))
    }

    /// Write any pending messages to the multiplexer. By definition all pending writes are flushed.
    private func writePendingToMultiplexer() {
        guard !self.pendingWritesForMultiplexer.isEmpty else { return }

        var didWrite = false

        let channelID = self.state.localChannelIdentifier

        self.logger.trace("Bundle Into Frame")
        self.logger.trace("\(self.pendingWritesForMultiplexer)")
        while let (write, promise) = self.pendingWritesForMultiplexer.bundleIntoFrame(
            channelID: channelID,
            shouldSendClose: pendingWritesFromChannel.isEmpty,
            loop: self.eventLoop
        ) {
            didWrite = true
            self.logger.trace("Frame: \(write)")
            self.multiplexer.writeFromChannel(write, promise)
        }

        if didWrite {
            self.multiplexer.childChannelFlush()
        }
    }
}

// MARK: General messages from the multiplexer

extension ChildChannel {
    func receiveParentChannelReadComplete() {
        self.logger.trace("Received ParentChannel Read Complete")
        self.tryToRead()

        /// All pending writes for the multiplexer are inherently flushed. Get rid of them
        /// here in case we auto-generated any.
        self.writePendingToMultiplexer()
    }

    func parentChannelWritabilityChanged(newValue: Bool) {
        guard case .changed(newValue: let localValue) = self.writabilityManager.parentWritabilityChanged(newValue)
        else {
            return
        }

        // Ok, the writability changed.
        if self.state.isActiveOnChannel {
            self.changeWritability(to: localValue)
        }
    }

    func closeChannel() -> EventLoopFuture<Void> {
        if self.state.isActiveOnNetwork {
            if !self.state.sentClose {
                self.logger.trace("Received Close Request While Active, Sending Close Message")
                // Write our close message
                self.processOutboundMessage(
                    .channelClose(.init(recipientChannel: channelID)),
                    promise: nil
                )
                // Force a flush asap
                self.writePendingToMultiplexer()
            }
        } else {
            self.logger.trace("Received Close Request - Short Circuit")
        }
        return self.closeFuture
    }

    func parentChannelInactive() {
        // The parent has gone inactive. If we're already closed, do nothing. Otherwise, this is an error that forces us directly into
        // closed.
        if !self.state.isClosed {
            self.state.receiveTCPEOF()
            self.errorEncountered(error: YAMUX.Error.tcpShutdown)
        }
    }
}

// MARK: Activation state management

extension ChildChannel {
    /// An enum to keep track of whether we've notified the channel of activation or not.
    private enum ActivationState {
        case neverActivated
        case activated
        case deactivated
    }

    /// This function handles the state required to notify the channel of activity. It can safely
    /// be called repeatedly, and will only activate the channel once.
    func notifyChannelActive() {
        switch self.activationState {
        case .neverActivated:
            self.activationState = .activated
            self._isActive.store(true, ordering: .relaxed)
            self.pipeline.fireChannelActive()

        case .activated:
            assert(self._isActive.load(ordering: .relaxed) == true)

        case .deactivated:
            assert(self._isActive.load(ordering: .relaxed) == false)
        }
    }

    func notifyChannelInactive() {
        switch self.activationState {
        case .neverActivated:
            // Do nothing, transition to inactive.
            self.activationState = .deactivated
            assert(self._isActive.load(ordering: .relaxed) == false)

        case .activated:
            self.activationState = .deactivated
            self._isActive.store(false, ordering: .relaxed)
            self.pipeline.fireChannelInactive()

        case .deactivated:
            assert(self._isActive.load(ordering: .relaxed) == false)
        }
    }
}

//typealias PendingContent = ByteBuffer
extension ChildChannel {
    fileprivate enum PendingContent {
        case data(ByteBuffer)
        //case eof

        var readableBytes: Int {
            switch self {
            case .data(let d):
                return d.readableBytes
            //case .eof:
            //    return 0
            }
        }

        func trim(maxLength: Int) -> (trimmed: PendingContent, excess: PendingContent?) {
            guard case .data(var channelData) = self else {
                // No need to trim EOF
                return (trimmed: self, excess: nil)
            }

            // No need to trim here either.
            if channelData.readableBytes <= maxLength {
                return (trimmed: self, excess: nil)
            }

            // Ok, gotta trim.
            let prefix = channelData.readSlice(length: maxLength)!
            return (trimmed: .data(prefix), excess: .data(channelData))
        }
    }
}

extension ChildChannel {
    internal struct SynchronousOptions: NIOSynchronousChannelOptions {
        private let channel: ChildChannel

        fileprivate init(channel: ChildChannel) {
            self.channel = channel
        }

        /// Set `option` to `value` on this `Channel`.
        ///
        /// - Important: Must be called on the `EventLoop` the `Channel` is running on.
        internal func setOption<Option: ChannelOption>(_ option: Option, value: Option.Value) throws {
            try self.channel.setOption0(option, value: value)
        }

        /// Get the value of `option` for this `Channel`.
        ///
        /// - Important: Must be called on the `EventLoop` the `Channel` is running on.
        internal func getOption<Option: ChannelOption>(_ option: Option) throws -> Option.Value {
            try self.channel.getOption0(option)
        }
    }

    /// Returns a view of the `Channel` exposing synchronous versions of `setOption` and `getOption`.
    public var syncOptions: NIOSynchronousChannelOptions? {
        SynchronousOptions(channel: self)
    }
}

extension IOData {
    fileprivate mutating func slicePrefix(_ length: Int) -> IOData {
        assert(length < self.readableBytes)

        switch self {
        case .byteBuffer(var buf):
            // This force-unwrap is safe, as we only invoke this when we have already checked the length.
            let newBuf = buf.readSlice(length: length)!
            self = .byteBuffer(buf)
            return .byteBuffer(newBuf)

        case .fileRegion(var region):
            let newRegion = FileRegion(
                fileHandle: region.fileHandle,
                readerIndex: region.readerIndex,
                endIndex: region.readerIndex + length
            )
            region.moveReaderIndex(forwardBy: length)
            self = .fileRegion(region)
            return .fileRegion(newRegion)
        }
    }
}

extension CircularBuffer where Element == (Message, EventLoopPromise<Void>?) {
    func containsCarrierMessage() -> Bool {
        self.contains(where: { msg, _ in
            msg.isCarrierType
        })
    }

    mutating func bundleIntoFrame(
        channelID: UInt32,
        shouldSendClose: Bool,
        loop: EventLoop
    ) -> (Frame, EventLoopPromise<Void>)? {
        guard !self.isEmpty else { return nil }
        var payload: ByteBuffer? = nil
        var flags: Set<Header.Flag> = []
        var messageType: Header.MessageType? = nil
        var length: UInt32? = nil
        let p = loop.makePromise(of: Void.self)
        while let (msg, promise) = self.popFirst() {
            if messageType != nil {
                guard msg.isFlagType else {
                    // Put the message back
                    self.insert((msg, promise), at: self.startIndex)
                    break
                }
            }
            promise?.completeWith(p.futureResult)
            //p.futureResult.cascade(to: promise)
            switch msg {
            case .channelOpen:
                flags.insert(.syn)
            case .channelOpenConfirmation:
                flags.insert(.ack)
            case .channelClose:
                if shouldSendClose {
                    flags.insert(.fin)
                } else {
                    self.insert((msg, promise), at: self.endIndex)
                }
            case .channelOpenFailure, .channelReset:
                flags.insert(.reset)
            case .channelData(let msg):
                messageType = .data
                payload = msg.data
                length = UInt32(msg.data.readableBytes)
            case .channelWindowAdjust(let msg):
                messageType = .windowUpdate
                length = msg.bytesToAdd
            default:
                fatalError("Unsupported message type on ChildChannel")
            }
        }

        let header = Header(
            version: .v0,
            messageType: messageType ?? .windowUpdate,
            flags: flags,
            streamID: channelID,
            length: length ?? 0
        )

        let frame = Frame(header: header, payload: payload)

        return (frame, p)
    }
}

extension Message {
    var isFlagType: Bool {
        !self.isCarrierType
    }

    var isCarrierType: Bool {
        switch self {
        case .channelOpen, .channelClose, .channelReset, .channelOpenConfirmation, .channelOpenFailure, .sessionOpen,
            .sessionOpenConfirmation:
            return false
        case .channelData, .channelWindowAdjust, .ping, .disconnect:
            return true
        }
    }
}
